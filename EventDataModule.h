//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `EventDataModule.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __EventDataModule_h__
#define __EventDataModule_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace EventDataModule
{

class EventsDataInterface;
class EventsDataInterfacePrx;

}

namespace EventDataModule
{

enum class Table : unsigned char
{
    clients,
    events,
    services
};

enum class EventField : unsigned char
{
    clientId,
    dateTime,
    date,
    time,
    duration,
    location,
    observations
};

enum class ServiceField : unsigned char
{
    providerIdentity,
    providerService,
    dateTime,
    duration,
    cost,
    description,
    observations
};

struct ClientData
{
    int id;
    ::std::string name;
    ::std::string phone;
    ::std::string specialNote;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, name, phone, specialNote);
    }
};

using SeqClients = ::std::vector<ClientData>;

struct ServiceData
{
    int id;
    int eventId;
    ::std::string providerIdentity;
    ::std::string providerService;
    ::std::string dateTime;
    double duration;
    int cost;
    ::std::string description;
    ::std::string observations;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const double&, const int&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, eventId, providerIdentity, providerService, dateTime, duration, cost, description, observations);
    }
};

using SeqServices = ::std::vector<ServiceData>;

struct EventData
{
    int id;
    int clientId;
    double duration;
    ::std::string dateTime;
    ::std::string location;
    ::std::string observations;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const double&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, clientId, duration, dateTime, location, observations);
    }
};

struct EventDataPack
{
    ::EventDataModule::ClientData clientData;
    ::EventDataModule::EventData eventData;
    ::EventDataModule::SeqServices seqServices;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::EventDataModule::ClientData&, const ::EventDataModule::EventData&, const ::EventDataModule::SeqServices&> ice_tuple() const
    {
        return std::tie(clientData, eventData, seqServices);
    }
};

using SeqEventDataPack = ::std::vector<EventDataPack>;

struct InitialDataSetup
{
    ::EventDataModule::SeqEventDataPack seqEventDataPack;
    ::EventDataModule::SeqClients seqClients;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::EventDataModule::SeqEventDataPack&, const ::EventDataModule::SeqClients&> ice_tuple() const
    {
        return std::tie(seqEventDataPack, seqClients);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace EventDataModule
{

class EventsDataInterface : public virtual ::Ice::Object
{
public:

    using ProxyType = EventsDataInterfacePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual SeqEventDataPack getEventsData(::std::string userToken, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventsData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClients getClientsByName(::std::string userToken, ::std::string partialName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClients getClientsByPhone(::std::string userToken, ::std::string partialPhone, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByPhone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventDataPack getEventData(::std::string userToken, int eventId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqEventDataPack getTenEvents(::std::string userToken, ::std::string fromDate, int offset, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTenEvents(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventDataPack registerEvent(::std::string userToken, EventDataPack eventDataPack, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventIntField(::std::string userToken, int eventId, EventField field, int newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventStringField(::std::string userToken, int eventId, EventField field, ::std::string newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventDoubleField(::std::string userToken, int eventId, EventField field, double newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addServiceToEvent(::std::string userToken, ServiceData serviceData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addServiceToEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceIntField(::std::string userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceStringField(::std::string userToken, int serviceId, ServiceField field, ::std::string newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceDoubleField(::std::string userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int registerClient(::std::string userToken, ClientData clientData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyClient(::std::string userToken, ClientData clientData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void deleteRecord(::std::string userToken, Table table, int id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteRecord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace EventDataModule
{

class EventsDataInterfacePrx : public virtual ::Ice::Proxy<EventsDataInterfacePrx, ::Ice::ObjectPrx>
{
public:

    SeqEventDataPack getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::SeqEventDataPack>(true, this, &EventsDataInterfacePrx::_iceI_getEventsData, userToken, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEventsDataAsync(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::SeqEventDataPack>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::SeqEventDataPack, P>(false, this, &EventsDataInterfacePrx::_iceI_getEventsData, userToken, context);
    }

    ::std::function<void()>
    getEventsDataAsync(const ::std::string& userToken,
                       ::std::function<void(::EventDataModule::SeqEventDataPack)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::SeqEventDataPack>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_getEventsData, userToken, context);
    }

    /// \cond INTERNAL
    void _iceI_getEventsData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::SeqEventDataPack>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    SeqClients getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::SeqClients>(true, this, &EventsDataInterfacePrx::_iceI_getClientsByName, userToken, partialName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClientsByNameAsync(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::SeqClients>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::SeqClients, P>(false, this, &EventsDataInterfacePrx::_iceI_getClientsByName, userToken, partialName, context);
    }

    ::std::function<void()>
    getClientsByNameAsync(const ::std::string& userToken, const ::std::string& partialName,
                          ::std::function<void(::EventDataModule::SeqClients)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::SeqClients>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_getClientsByName, userToken, partialName, context);
    }

    /// \cond INTERNAL
    void _iceI_getClientsByName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::SeqClients>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    SeqClients getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::SeqClients>(true, this, &EventsDataInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClientsByPhoneAsync(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::SeqClients>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::SeqClients, P>(false, this, &EventsDataInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context);
    }

    ::std::function<void()>
    getClientsByPhoneAsync(const ::std::string& userToken, const ::std::string& partialPhone,
                           ::std::function<void(::EventDataModule::SeqClients)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::SeqClients>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context);
    }

    /// \cond INTERNAL
    void _iceI_getClientsByPhone(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::SeqClients>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    EventDataPack getEventData(const ::std::string& userToken, int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::EventDataPack>(true, this, &EventsDataInterfacePrx::_iceI_getEventData, userToken, eventId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEventDataAsync(const ::std::string& userToken, int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::EventDataPack>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::EventDataPack, P>(false, this, &EventsDataInterfacePrx::_iceI_getEventData, userToken, eventId, context);
    }

    ::std::function<void()>
    getEventDataAsync(const ::std::string& userToken, int eventId,
                      ::std::function<void(::EventDataModule::EventDataPack)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::EventDataPack>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_getEventData, userToken, eventId, context);
    }

    /// \cond INTERNAL
    void _iceI_getEventData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::EventDataPack>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    SeqEventDataPack getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::SeqEventDataPack>(true, this, &EventsDataInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTenEventsAsync(const ::std::string& userToken, const ::std::string& fromDate, int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::SeqEventDataPack>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::SeqEventDataPack, P>(false, this, &EventsDataInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context);
    }

    ::std::function<void()>
    getTenEventsAsync(const ::std::string& userToken, const ::std::string& fromDate, int offset,
                      ::std::function<void(::EventDataModule::SeqEventDataPack)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::SeqEventDataPack>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context);
    }

    /// \cond INTERNAL
    void _iceI_getTenEvents(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::SeqEventDataPack>>&, const ::std::string&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    EventDataPack registerEvent(const ::std::string& userToken, const EventDataPack& eventDataPack, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventDataModule::EventDataPack>(true, this, &EventsDataInterfacePrx::_iceI_registerEvent, userToken, eventDataPack, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerEventAsync(const ::std::string& userToken, const EventDataPack& eventDataPack, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventDataModule::EventDataPack>>().get_future())
    {
        return _makePromiseOutgoing<::EventDataModule::EventDataPack, P>(false, this, &EventsDataInterfacePrx::_iceI_registerEvent, userToken, eventDataPack, context);
    }

    ::std::function<void()>
    registerEventAsync(const ::std::string& userToken, const EventDataPack& eventDataPack,
                       ::std::function<void(::EventDataModule::EventDataPack)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventDataModule::EventDataPack>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_registerEvent, userToken, eventDataPack, context);
    }

    /// \cond INTERNAL
    void _iceI_registerEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventDataModule::EventDataPack>>&, const ::std::string&, const EventDataPack&, const ::Ice::Context&);
    /// \endcond

    void modifyEventIntField(const ::std::string& userToken, int eventId, EventField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventIntFieldAsync(const ::std::string& userToken, int eventId, EventField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventIntFieldAsync(const ::std::string& userToken, int eventId, EventField field, int newValue,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventIntField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, int, const ::Ice::Context&);
    /// \endcond

    void modifyEventStringField(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventStringFieldAsync(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventStringFieldAsync(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventStringField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void modifyEventDoubleField(const ::std::string& userToken, int eventId, EventField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventDoubleFieldAsync(const ::std::string& userToken, int eventId, EventField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventDoubleFieldAsync(const ::std::string& userToken, int eventId, EventField field, double newValue,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventDoubleField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, double, const ::Ice::Context&);
    /// \endcond

    void addServiceToEvent(const ::std::string& userToken, const ServiceData& serviceData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_addServiceToEvent, userToken, serviceData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addServiceToEventAsync(const ::std::string& userToken, const ServiceData& serviceData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_addServiceToEvent, userToken, serviceData, context);
    }

    ::std::function<void()>
    addServiceToEventAsync(const ::std::string& userToken, const ServiceData& serviceData,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_addServiceToEvent, userToken, serviceData, context);
    }

    /// \cond INTERNAL
    void _iceI_addServiceToEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ServiceData&, const ::Ice::Context&);
    /// \endcond

    void modifyServiceIntField(const ::std::string& userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceIntFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceIntFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, int newValue,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceIntField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, int, const ::Ice::Context&);
    /// \endcond

    void modifyServiceStringField(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceStringFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceStringFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceStringField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void modifyServiceDoubleField(const ::std::string& userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceDoubleFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceDoubleFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, double newValue,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceDoubleField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, double, const ::Ice::Context&);
    /// \endcond

    int registerClient(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &EventsDataInterfacePrx::_iceI_registerClient, userToken, clientData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerClientAsync(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &EventsDataInterfacePrx::_iceI_registerClient, userToken, clientData, context);
    }

    ::std::function<void()>
    registerClientAsync(const ::std::string& userToken, const ClientData& clientData,
                        ::std::function<void(int)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_registerClient, userToken, clientData, context);
    }

    /// \cond INTERNAL
    void _iceI_registerClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ClientData&, const ::Ice::Context&);
    /// \endcond

    void modifyClient(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_modifyClient, userToken, clientData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyClientAsync(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_modifyClient, userToken, clientData, context);
    }

    ::std::function<void()>
    modifyClientAsync(const ::std::string& userToken, const ClientData& clientData,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_modifyClient, userToken, clientData, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ClientData&, const ::Ice::Context&);
    /// \endcond

    void deleteRecord(const ::std::string& userToken, Table table, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventsDataInterfacePrx::_iceI_deleteRecord, userToken, table, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto deleteRecordAsync(const ::std::string& userToken, Table table, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventsDataInterfacePrx::_iceI_deleteRecord, userToken, table, id, context);
    }

    ::std::function<void()>
    deleteRecordAsync(const ::std::string& userToken, Table table, int id,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventDataModule::EventsDataInterfacePrx::_iceI_deleteRecord, userToken, table, id, context);
    }

    /// \cond INTERNAL
    void _iceI_deleteRecord(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, Table, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EventsDataInterfacePrx() = default;
    friend ::std::shared_ptr<EventsDataInterfacePrx> IceInternal::createProxy<EventsDataInterfacePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::EventDataModule::Table>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventDataModule::EventField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventDataModule::ServiceField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::EventDataModule::ClientData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventDataModule::ClientData, S>
{
    static void read(S* istr, ::EventDataModule::ClientData& v)
    {
        istr->readAll(v.id, v.name, v.phone, v.specialNote);
    }
};

template<>
struct StreamableTraits<::EventDataModule::ServiceData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 25;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventDataModule::ServiceData, S>
{
    static void read(S* istr, ::EventDataModule::ServiceData& v)
    {
        istr->readAll(v.id, v.eventId, v.providerIdentity, v.providerService, v.dateTime, v.duration, v.cost, v.description, v.observations);
    }
};

template<>
struct StreamableTraits<::EventDataModule::EventData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventDataModule::EventData, S>
{
    static void read(S* istr, ::EventDataModule::EventData& v)
    {
        istr->readAll(v.id, v.clientId, v.duration, v.dateTime, v.location, v.observations);
    }
};

template<>
struct StreamableTraits<::EventDataModule::EventDataPack>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 27;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventDataModule::EventDataPack, S>
{
    static void read(S* istr, ::EventDataModule::EventDataPack& v)
    {
        istr->readAll(v.clientData, v.eventData, v.seqServices);
    }
};

template<>
struct StreamableTraits<::EventDataModule::InitialDataSetup>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventDataModule::InitialDataSetup, S>
{
    static void read(S* istr, ::EventDataModule::InitialDataSetup& v)
    {
        istr->readAll(v.seqEventDataPack, v.seqClients);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace EventDataModule
{

using EventsDataInterfacePtr = ::std::shared_ptr<EventsDataInterface>;
using EventsDataInterfacePrxPtr = ::std::shared_ptr<EventsDataInterfacePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace EventDataModule
{

class EventsDataInterface;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EventsDataInterface>&);
::IceProxy::Ice::Object* upCast(EventsDataInterface*);
/// \endcond

}

}

namespace EventDataModule
{

class EventsDataInterface;
/// \cond INTERNAL
::Ice::Object* upCast(EventsDataInterface*);
/// \endcond
typedef ::IceInternal::Handle< EventsDataInterface> EventsDataInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::EventDataModule::EventsDataInterface> EventsDataInterfacePrx;
typedef EventsDataInterfacePrx EventsDataInterfacePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EventsDataInterfacePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace EventDataModule
{

enum Table
{
    clients,
    events,
    services
};

enum EventField
{
    clientId,
    dateTime,
    date,
    time,
    duration,
    location,
    observations
};

enum ServiceField
{
    providerIdentity,
    providerService,
    dateTime,
    duration,
    cost,
    description,
    observations
};

struct ClientData
{
    ::Ice::Int id;
    ::std::string name;
    ::std::string phone;
    ::std::string specialNote;

    bool operator==(const ClientData& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(name != rhs_.name)
        {
            return false;
        }
        if(phone != rhs_.phone)
        {
            return false;
        }
        if(specialNote != rhs_.specialNote)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClientData& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(name < rhs_.name)
        {
            return true;
        }
        else if(rhs_.name < name)
        {
            return false;
        }
        if(phone < rhs_.phone)
        {
            return true;
        }
        else if(rhs_.phone < phone)
        {
            return false;
        }
        if(specialNote < rhs_.specialNote)
        {
            return true;
        }
        else if(rhs_.specialNote < specialNote)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClientData& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClientData& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClientData& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClientData& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ClientData> SeqClients;

struct ServiceData
{
    ::Ice::Int id;
    ::Ice::Int eventId;
    ::std::string providerIdentity;
    ::std::string providerService;
    ::std::string dateTime;
    ::Ice::Double duration;
    ::Ice::Int cost;
    ::std::string description;
    ::std::string observations;
};

typedef ::std::vector<ServiceData> SeqServices;

struct EventData
{
    ::Ice::Int id;
    ::Ice::Int clientId;
    ::Ice::Double duration;
    ::std::string dateTime;
    ::std::string location;
    ::std::string observations;
};

struct EventDataPack
{
    ::EventDataModule::ClientData clientData;
    ::EventDataModule::EventData eventData;
    ::EventDataModule::SeqServices seqServices;
};

typedef ::std::vector<EventDataPack> SeqEventDataPack;

struct InitialDataSetup
{
    ::EventDataModule::SeqEventDataPack seqEventDataPack;
    ::EventDataModule::SeqClients seqClients;
};

}

namespace EventDataModule
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventsData.
 */
class Callback_EventsDataInterface_getEventsData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_getEventsData_Base> Callback_EventsDataInterface_getEventsDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByName.
 */
class Callback_EventsDataInterface_getClientsByName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_getClientsByName_Base> Callback_EventsDataInterface_getClientsByNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByPhone.
 */
class Callback_EventsDataInterface_getClientsByPhone_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_getClientsByPhone_Base> Callback_EventsDataInterface_getClientsByPhonePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventData.
 */
class Callback_EventsDataInterface_getEventData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_getEventData_Base> Callback_EventsDataInterface_getEventDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getTenEvents.
 */
class Callback_EventsDataInterface_getTenEvents_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_getTenEvents_Base> Callback_EventsDataInterface_getTenEventsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerEvent.
 */
class Callback_EventsDataInterface_registerEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_registerEvent_Base> Callback_EventsDataInterface_registerEventPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventIntField.
 */
class Callback_EventsDataInterface_modifyEventIntField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyEventIntField_Base> Callback_EventsDataInterface_modifyEventIntFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventStringField.
 */
class Callback_EventsDataInterface_modifyEventStringField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyEventStringField_Base> Callback_EventsDataInterface_modifyEventStringFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventDoubleField.
 */
class Callback_EventsDataInterface_modifyEventDoubleField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyEventDoubleField_Base> Callback_EventsDataInterface_modifyEventDoubleFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_addServiceToEvent.
 */
class Callback_EventsDataInterface_addServiceToEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_addServiceToEvent_Base> Callback_EventsDataInterface_addServiceToEventPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceIntField.
 */
class Callback_EventsDataInterface_modifyServiceIntField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyServiceIntField_Base> Callback_EventsDataInterface_modifyServiceIntFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceStringField.
 */
class Callback_EventsDataInterface_modifyServiceStringField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyServiceStringField_Base> Callback_EventsDataInterface_modifyServiceStringFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceDoubleField.
 */
class Callback_EventsDataInterface_modifyServiceDoubleField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyServiceDoubleField_Base> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerClient.
 */
class Callback_EventsDataInterface_registerClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_registerClient_Base> Callback_EventsDataInterface_registerClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyClient.
 */
class Callback_EventsDataInterface_modifyClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_modifyClient_Base> Callback_EventsDataInterface_modifyClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_deleteRecord.
 */
class Callback_EventsDataInterface_deleteRecord_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventsDataInterface_deleteRecord_Base> Callback_EventsDataInterface_deleteRecordPtr;

}

namespace IceProxy
{

namespace EventDataModule
{

class EventsDataInterface : public virtual ::Ice::Proxy<EventsDataInterface, ::IceProxy::Ice::Object>
{
public:

    ::EventDataModule::SeqEventDataPack getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEventsData(_iceI_begin_getEventsData(userToken, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEventsData(userToken, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::EventDataModule::Callback_EventsDataInterface_getEventsDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_getEventsDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, context, cb, cookie);
    }

    ::EventDataModule::SeqEventDataPack end_getEventsData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEventsData(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventDataModule::SeqClients getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClientsByName(_iceI_begin_getClientsByName(userToken, partialName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::EventDataModule::Callback_EventsDataInterface_getClientsByNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_getClientsByNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, cb, cookie);
    }

    ::EventDataModule::SeqClients end_getClientsByName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClientsByName(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventDataModule::SeqClients getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClientsByPhone(_iceI_begin_getClientsByPhone(userToken, partialPhone, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::EventDataModule::Callback_EventsDataInterface_getClientsByPhonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_getClientsByPhonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, cb, cookie);
    }

    ::EventDataModule::SeqClients end_getClientsByPhone(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClientsByPhone(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventDataModule::EventDataPack getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEventData(_iceI_begin_getEventData(userToken, eventId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::EventDataModule::Callback_EventsDataInterface_getEventDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_getEventDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, cb, cookie);
    }

    ::EventDataModule::EventDataPack end_getEventData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEventData(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventDataModule::SeqEventDataPack getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTenEvents(_iceI_begin_getTenEvents(userToken, fromDate, offset, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::EventDataModule::Callback_EventsDataInterface_getTenEventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_getTenEventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, cb, cookie);
    }

    ::EventDataModule::SeqEventDataPack end_getTenEvents(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTenEvents(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventDataModule::EventDataPack registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerEvent(_iceI_begin_registerEvent(userToken, eventDataPack, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerEvent(userToken, eventDataPack, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventDataPack, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventDataPack, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::EventDataModule::Callback_EventsDataInterface_registerEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventDataPack, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventDataModule::EventDataPack& eventDataPack, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_registerEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventDataPack, context, cb, cookie);
    }

    ::EventDataModule::EventDataPack end_registerEvent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerEvent(const ::std::string&, const ::EventDataModule::EventDataPack&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventIntField(_iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyEventIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyEventIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventIntField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventIntField(const ::std::string&, ::Ice::Int, ::EventDataModule::EventField, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventStringField(_iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyEventStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyEventStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventStringField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventStringField(const ::std::string&, ::Ice::Int, ::EventDataModule::EventField, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventDoubleField(_iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyEventDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventDataModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyEventDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventDoubleField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventDoubleField(const ::std::string&, ::Ice::Int, ::EventDataModule::EventField, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addServiceToEvent(_iceI_begin_addServiceToEvent(userToken, serviceData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::EventDataModule::Callback_EventsDataInterface_addServiceToEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventDataModule::ServiceData& serviceData, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_addServiceToEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceData, context, cb, cookie);
    }

    void end_addServiceToEvent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addServiceToEvent(const ::std::string&, const ::EventDataModule::ServiceData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceIntField(_iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceIntField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceIntField(const ::std::string&, ::Ice::Int, ::EventDataModule::ServiceField, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceStringField(_iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceStringField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceStringField(const ::std::string&, ::Ice::Int, ::EventDataModule::ServiceField, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceDoubleField(_iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventDataModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyServiceDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceDoubleField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceDoubleField(const ::std::string&, ::Ice::Int, ::EventDataModule::ServiceField, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerClient(_iceI_begin_registerClient(userToken, clientData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerClient(userToken, clientData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::EventDataModule::Callback_EventsDataInterface_registerClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_registerClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientData, context, cb, cookie);
    }

    ::Ice::Int end_registerClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerClient(const ::std::string&, const ::EventDataModule::ClientData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyClient(_iceI_begin_modifyClient(userToken, clientData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyClient(userToken, clientData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::EventDataModule::Callback_EventsDataInterface_modifyClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventDataModule::ClientData& clientData, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_modifyClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientData, context, cb, cookie);
    }

    void end_modifyClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyClient(const ::std::string&, const ::EventDataModule::ClientData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_deleteRecord(_iceI_begin_deleteRecord(userToken, table, id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::EventDataModule::Callback_EventsDataInterface_deleteRecordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventDataModule::Table table, ::Ice::Int id, const ::Ice::Context& context, const ::EventDataModule::Callback_EventsDataInterface_deleteRecordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, cb, cookie);
    }

    void end_deleteRecord(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_deleteRecord(const ::std::string&, ::EventDataModule::Table, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace EventDataModule
{

class EventsDataInterface : public virtual ::Ice::Object
{
public:

    typedef EventsDataInterfacePrx ProxyType;
    typedef EventsDataInterfacePtr PointerType;

    virtual ~EventsDataInterface();

#ifdef ICE_CPP11_COMPILER
    EventsDataInterface() = default;
    EventsDataInterface(const EventsDataInterface&) = default;
    EventsDataInterface& operator=(const EventsDataInterface&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual SeqEventDataPack getEventsData(const ::std::string& userToken, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventsData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClients getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClients getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByPhone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventDataPack getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqEventDataPack getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTenEvents(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventDataPack registerEvent(const ::std::string& userToken, const EventDataPack& eventDataPack, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, ::Ice::Int newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, const ::std::string& newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, ::Ice::Double newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addServiceToEvent(const ::std::string& userToken, const ServiceData& serviceData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addServiceToEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, ::Ice::Int newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, ::Ice::Double newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int registerClient(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyClient(const ::std::string& userToken, const ClientData& clientData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void deleteRecord(const ::std::string& userToken, Table table, ::Ice::Int id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteRecord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const EventsDataInterface& lhs, const EventsDataInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EventsDataInterface& lhs, const EventsDataInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::EventDataModule::Table>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventDataModule::EventField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventDataModule::ServiceField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventDataModule::ClientData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventDataModule::ClientData, S>
{
    static void write(S* ostr, const ::EventDataModule::ClientData& v)
    {
        ostr->write(v.id);
        ostr->write(v.name);
        ostr->write(v.phone);
        ostr->write(v.specialNote);
    }
};

template<typename S>
struct StreamReader< ::EventDataModule::ClientData, S>
{
    static void read(S* istr, ::EventDataModule::ClientData& v)
    {
        istr->read(v.id);
        istr->read(v.name);
        istr->read(v.phone);
        istr->read(v.specialNote);
    }
};

template<>
struct StreamableTraits< ::EventDataModule::ServiceData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 25;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventDataModule::ServiceData, S>
{
    static void write(S* ostr, const ::EventDataModule::ServiceData& v)
    {
        ostr->write(v.id);
        ostr->write(v.eventId);
        ostr->write(v.providerIdentity);
        ostr->write(v.providerService);
        ostr->write(v.dateTime);
        ostr->write(v.duration);
        ostr->write(v.cost);
        ostr->write(v.description);
        ostr->write(v.observations);
    }
};

template<typename S>
struct StreamReader< ::EventDataModule::ServiceData, S>
{
    static void read(S* istr, ::EventDataModule::ServiceData& v)
    {
        istr->read(v.id);
        istr->read(v.eventId);
        istr->read(v.providerIdentity);
        istr->read(v.providerService);
        istr->read(v.dateTime);
        istr->read(v.duration);
        istr->read(v.cost);
        istr->read(v.description);
        istr->read(v.observations);
    }
};

template<>
struct StreamableTraits< ::EventDataModule::EventData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventDataModule::EventData, S>
{
    static void write(S* ostr, const ::EventDataModule::EventData& v)
    {
        ostr->write(v.id);
        ostr->write(v.clientId);
        ostr->write(v.duration);
        ostr->write(v.dateTime);
        ostr->write(v.location);
        ostr->write(v.observations);
    }
};

template<typename S>
struct StreamReader< ::EventDataModule::EventData, S>
{
    static void read(S* istr, ::EventDataModule::EventData& v)
    {
        istr->read(v.id);
        istr->read(v.clientId);
        istr->read(v.duration);
        istr->read(v.dateTime);
        istr->read(v.location);
        istr->read(v.observations);
    }
};

template<>
struct StreamableTraits< ::EventDataModule::EventDataPack>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 27;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventDataModule::EventDataPack, S>
{
    static void write(S* ostr, const ::EventDataModule::EventDataPack& v)
    {
        ostr->write(v.clientData);
        ostr->write(v.eventData);
        ostr->write(v.seqServices);
    }
};

template<typename S>
struct StreamReader< ::EventDataModule::EventDataPack, S>
{
    static void read(S* istr, ::EventDataModule::EventDataPack& v)
    {
        istr->read(v.clientData);
        istr->read(v.eventData);
        istr->read(v.seqServices);
    }
};

template<>
struct StreamableTraits< ::EventDataModule::InitialDataSetup>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventDataModule::InitialDataSetup, S>
{
    static void write(S* ostr, const ::EventDataModule::InitialDataSetup& v)
    {
        ostr->write(v.seqEventDataPack);
        ostr->write(v.seqClients);
    }
};

template<typename S>
struct StreamReader< ::EventDataModule::InitialDataSetup, S>
{
    static void read(S* istr, ::EventDataModule::InitialDataSetup& v)
    {
        istr->read(v.seqEventDataPack);
        istr->read(v.seqClients);
    }
};

}
/// \endcond

namespace EventDataModule
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventsData.
 */
template<class T>
class CallbackNC_EventsDataInterface_getEventsData : public Callback_EventsDataInterface_getEventsData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqEventDataPack&);

    CallbackNC_EventsDataInterface_getEventsData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventDataPack ret;
        try
        {
            ret = proxy->end_getEventsData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 */
template<class T> Callback_EventsDataInterface_getEventsDataPtr
newCallback_EventsDataInterface_getEventsData(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getEventsData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 */
template<class T> Callback_EventsDataInterface_getEventsDataPtr
newCallback_EventsDataInterface_getEventsData(T* instance, void (T::*cb)(const SeqEventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getEventsData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventsData.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_getEventsData : public Callback_EventsDataInterface_getEventsData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqEventDataPack&, const CT&);

    Callback_EventsDataInterface_getEventsData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventDataPack ret;
        try
        {
            ret = proxy->end_getEventsData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 */
template<class T, typename CT> Callback_EventsDataInterface_getEventsDataPtr
newCallback_EventsDataInterface_getEventsData(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getEventsData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventsData.
 */
template<class T, typename CT> Callback_EventsDataInterface_getEventsDataPtr
newCallback_EventsDataInterface_getEventsData(T* instance, void (T::*cb)(const SeqEventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getEventsData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByName.
 */
template<class T>
class CallbackNC_EventsDataInterface_getClientsByName : public Callback_EventsDataInterface_getClientsByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqClients&);

    CallbackNC_EventsDataInterface_getClientsByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqClients ret;
        try
        {
            ret = proxy->end_getClientsByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 */
template<class T> Callback_EventsDataInterface_getClientsByNamePtr
newCallback_EventsDataInterface_getClientsByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClients&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getClientsByName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 */
template<class T> Callback_EventsDataInterface_getClientsByNamePtr
newCallback_EventsDataInterface_getClientsByName(T* instance, void (T::*cb)(const SeqClients&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getClientsByName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByName.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_getClientsByName : public Callback_EventsDataInterface_getClientsByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqClients&, const CT&);

    Callback_EventsDataInterface_getClientsByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqClients ret;
        try
        {
            ret = proxy->end_getClientsByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 */
template<class T, typename CT> Callback_EventsDataInterface_getClientsByNamePtr
newCallback_EventsDataInterface_getClientsByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClients&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getClientsByName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByName.
 */
template<class T, typename CT> Callback_EventsDataInterface_getClientsByNamePtr
newCallback_EventsDataInterface_getClientsByName(T* instance, void (T::*cb)(const SeqClients&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getClientsByName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByPhone.
 */
template<class T>
class CallbackNC_EventsDataInterface_getClientsByPhone : public Callback_EventsDataInterface_getClientsByPhone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqClients&);

    CallbackNC_EventsDataInterface_getClientsByPhone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqClients ret;
        try
        {
            ret = proxy->end_getClientsByPhone(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 */
template<class T> Callback_EventsDataInterface_getClientsByPhonePtr
newCallback_EventsDataInterface_getClientsByPhone(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClients&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getClientsByPhone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 */
template<class T> Callback_EventsDataInterface_getClientsByPhonePtr
newCallback_EventsDataInterface_getClientsByPhone(T* instance, void (T::*cb)(const SeqClients&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getClientsByPhone<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getClientsByPhone.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_getClientsByPhone : public Callback_EventsDataInterface_getClientsByPhone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqClients&, const CT&);

    Callback_EventsDataInterface_getClientsByPhone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqClients ret;
        try
        {
            ret = proxy->end_getClientsByPhone(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 */
template<class T, typename CT> Callback_EventsDataInterface_getClientsByPhonePtr
newCallback_EventsDataInterface_getClientsByPhone(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClients&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getClientsByPhone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getClientsByPhone.
 */
template<class T, typename CT> Callback_EventsDataInterface_getClientsByPhonePtr
newCallback_EventsDataInterface_getClientsByPhone(T* instance, void (T::*cb)(const SeqClients&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getClientsByPhone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventData.
 */
template<class T>
class CallbackNC_EventsDataInterface_getEventData : public Callback_EventsDataInterface_getEventData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EventDataPack&);

    CallbackNC_EventsDataInterface_getEventData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        EventDataPack ret;
        try
        {
            ret = proxy->end_getEventData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 */
template<class T> Callback_EventsDataInterface_getEventDataPtr
newCallback_EventsDataInterface_getEventData(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getEventData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 */
template<class T> Callback_EventsDataInterface_getEventDataPtr
newCallback_EventsDataInterface_getEventData(T* instance, void (T::*cb)(const EventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getEventData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getEventData.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_getEventData : public Callback_EventsDataInterface_getEventData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EventDataPack&, const CT&);

    Callback_EventsDataInterface_getEventData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        EventDataPack ret;
        try
        {
            ret = proxy->end_getEventData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 */
template<class T, typename CT> Callback_EventsDataInterface_getEventDataPtr
newCallback_EventsDataInterface_getEventData(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getEventData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getEventData.
 */
template<class T, typename CT> Callback_EventsDataInterface_getEventDataPtr
newCallback_EventsDataInterface_getEventData(T* instance, void (T::*cb)(const EventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getEventData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getTenEvents.
 */
template<class T>
class CallbackNC_EventsDataInterface_getTenEvents : public Callback_EventsDataInterface_getTenEvents_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqEventDataPack&);

    CallbackNC_EventsDataInterface_getTenEvents(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventDataPack ret;
        try
        {
            ret = proxy->end_getTenEvents(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 */
template<class T> Callback_EventsDataInterface_getTenEventsPtr
newCallback_EventsDataInterface_getTenEvents(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getTenEvents<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 */
template<class T> Callback_EventsDataInterface_getTenEventsPtr
newCallback_EventsDataInterface_getTenEvents(T* instance, void (T::*cb)(const SeqEventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_getTenEvents<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_getTenEvents.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_getTenEvents : public Callback_EventsDataInterface_getTenEvents_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqEventDataPack&, const CT&);

    Callback_EventsDataInterface_getTenEvents(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventDataPack ret;
        try
        {
            ret = proxy->end_getTenEvents(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 */
template<class T, typename CT> Callback_EventsDataInterface_getTenEventsPtr
newCallback_EventsDataInterface_getTenEvents(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getTenEvents<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_getTenEvents.
 */
template<class T, typename CT> Callback_EventsDataInterface_getTenEventsPtr
newCallback_EventsDataInterface_getTenEvents(T* instance, void (T::*cb)(const SeqEventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_getTenEvents<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerEvent.
 */
template<class T>
class CallbackNC_EventsDataInterface_registerEvent : public Callback_EventsDataInterface_registerEvent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EventDataPack&);

    CallbackNC_EventsDataInterface_registerEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        EventDataPack ret;
        try
        {
            ret = proxy->end_registerEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 */
template<class T> Callback_EventsDataInterface_registerEventPtr
newCallback_EventsDataInterface_registerEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_registerEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 */
template<class T> Callback_EventsDataInterface_registerEventPtr
newCallback_EventsDataInterface_registerEvent(T* instance, void (T::*cb)(const EventDataPack&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_registerEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerEvent.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_registerEvent : public Callback_EventsDataInterface_registerEvent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EventDataPack&, const CT&);

    Callback_EventsDataInterface_registerEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        EventDataPack ret;
        try
        {
            ret = proxy->end_registerEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_registerEventPtr
newCallback_EventsDataInterface_registerEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_registerEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_registerEventPtr
newCallback_EventsDataInterface_registerEvent(T* instance, void (T::*cb)(const EventDataPack&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_registerEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventIntField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyEventIntField : public Callback_EventsDataInterface_modifyEventIntField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyEventIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventIntField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyEventIntField : public Callback_EventsDataInterface_modifyEventIntField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyEventIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventIntFieldPtr
newCallback_EventsDataInterface_modifyEventIntField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventStringField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyEventStringField : public Callback_EventsDataInterface_modifyEventStringField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyEventStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventStringField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyEventStringField : public Callback_EventsDataInterface_modifyEventStringField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyEventStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventStringFieldPtr
newCallback_EventsDataInterface_modifyEventStringField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventDoubleField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyEventDoubleField : public Callback_EventsDataInterface_modifyEventDoubleField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyEventDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyEventDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyEventDoubleField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyEventDoubleField : public Callback_EventsDataInterface_modifyEventDoubleField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyEventDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyEventDoubleFieldPtr
newCallback_EventsDataInterface_modifyEventDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyEventDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_addServiceToEvent.
 */
template<class T>
class CallbackNC_EventsDataInterface_addServiceToEvent : public Callback_EventsDataInterface_addServiceToEvent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_addServiceToEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_addServiceToEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_addServiceToEvent<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_addServiceToEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_addServiceToEvent<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_addServiceToEvent.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_addServiceToEvent : public Callback_EventsDataInterface_addServiceToEvent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_addServiceToEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_addServiceToEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_addServiceToEvent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_addServiceToEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventsDataInterface_addServiceToEventPtr
newCallback_EventsDataInterface_addServiceToEvent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_addServiceToEvent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceIntField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyServiceIntField : public Callback_EventsDataInterface_modifyServiceIntField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyServiceIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceIntField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyServiceIntField : public Callback_EventsDataInterface_modifyServiceIntField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyServiceIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceIntFieldPtr
newCallback_EventsDataInterface_modifyServiceIntField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceStringField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyServiceStringField : public Callback_EventsDataInterface_modifyServiceStringField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyServiceStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceStringField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyServiceStringField : public Callback_EventsDataInterface_modifyServiceStringField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyServiceStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceStringFieldPtr
newCallback_EventsDataInterface_modifyServiceStringField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceDoubleField.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyServiceDoubleField : public Callback_EventsDataInterface_modifyServiceDoubleField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyServiceDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyServiceDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyServiceDoubleField.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyServiceDoubleField : public Callback_EventsDataInterface_modifyServiceDoubleField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyServiceDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyServiceDoubleFieldPtr
newCallback_EventsDataInterface_modifyServiceDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyServiceDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerClient.
 */
template<class T>
class CallbackNC_EventsDataInterface_registerClient : public Callback_EventsDataInterface_registerClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_EventsDataInterface_registerClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_registerClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 */
template<class T> Callback_EventsDataInterface_registerClientPtr
newCallback_EventsDataInterface_registerClient(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_registerClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 */
template<class T> Callback_EventsDataInterface_registerClientPtr
newCallback_EventsDataInterface_registerClient(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_registerClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_registerClient.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_registerClient : public Callback_EventsDataInterface_registerClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_EventsDataInterface_registerClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventsDataInterfacePrx proxy = EventsDataInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_registerClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_registerClientPtr
newCallback_EventsDataInterface_registerClient(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_registerClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_registerClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_registerClientPtr
newCallback_EventsDataInterface_registerClient(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_registerClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyClient.
 */
template<class T>
class CallbackNC_EventsDataInterface_modifyClient : public Callback_EventsDataInterface_modifyClient_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_modifyClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyClient<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_modifyClient<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_modifyClient.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_modifyClient : public Callback_EventsDataInterface_modifyClient_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_modifyClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventsDataInterface_modifyClientPtr
newCallback_EventsDataInterface_modifyClient(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_modifyClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_deleteRecord.
 */
template<class T>
class CallbackNC_EventsDataInterface_deleteRecord : public Callback_EventsDataInterface_deleteRecord_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventsDataInterface_deleteRecord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_deleteRecord<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_deleteRecord<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_deleteRecord<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventsDataInterface_deleteRecord<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventDataModule::newCallback_EventsDataInterface_deleteRecord.
 */
template<class T, typename CT>
class Callback_EventsDataInterface_deleteRecord : public Callback_EventsDataInterface_deleteRecord_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventsDataInterface_deleteRecord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_deleteRecord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_deleteRecord<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_deleteRecord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventDataModule::EventsDataInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventsDataInterface_deleteRecordPtr
newCallback_EventsDataInterface_deleteRecord(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventsDataInterface_deleteRecord<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
