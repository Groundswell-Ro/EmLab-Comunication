//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `EventModule.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __EventModule_h__
#define __EventModule_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace EventModule
{

class EventInterface;
class EventInterfacePrx;

}

namespace EventModule
{

enum class Table : unsigned char
{
    clients,
    events,
    services
};

enum class EventField : unsigned char
{
    clientId,
    dateTime,
    date,
    time,
    duration,
    location,
    description
};

enum class ServiceField : unsigned char
{
    providerIdentity,
    providerService,
    dateTime,
    duration,
    cost,
    description,
    observations
};

enum class ClientField : unsigned char
{
    name,
    phone,
    specialNote
};

struct ClientInfo
{
    int id;
    ::std::string name;
    ::std::string phone;
    ::std::string specialNote;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, name, phone, specialNote);
    }
};

using SeqClientInfo = ::std::vector<ClientInfo>;

struct ServiceInfo
{
    int id;
    int eventId;
    ::std::string providerIdentity;
    ::std::string providerService;
    ::std::string dateTime;
    double duration;
    int cost;
    ::std::string description;
    ::std::string observations;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const double&, const int&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, eventId, providerIdentity, providerService, dateTime, duration, cost, description, observations);
    }
};

using SeqServiceInfo = ::std::vector<ServiceInfo>;

struct EventInfo
{
    int id;
    int clientId;
    double duration;
    ::std::string dateTime;
    ::std::string location;
    ::std::string description;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const double&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, clientId, duration, dateTime, location, description);
    }
};

using SeqEventInfo = ::std::vector<EventInfo>;

struct EventData
{
    ::EventModule::ClientInfo clientInfo;
    ::EventModule::EventInfo eventInfo;
    ::EventModule::SeqServiceInfo seqServiceInfo;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::EventModule::ClientInfo&, const ::EventModule::EventInfo&, const ::EventModule::SeqServiceInfo&> ice_tuple() const
    {
        return std::tie(clientInfo, eventInfo, seqServiceInfo);
    }
};

using SeqEventData = ::std::vector<EventData>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace EventModule
{

class EventInterface : public virtual ::Ice::Object
{
public:

    using ProxyType = EventInterfacePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual SeqEventData getEventsData(::std::string userToken, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventsData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClientInfo getClientsByName(::std::string userToken, ::std::string partialName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClientInfo getClientsByPhone(::std::string userToken, ::std::string partialPhone, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByPhone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventData getEventData(::std::string userToken, int eventId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqEventData getTenEvents(::std::string userToken, ::std::string fromDate, int offset, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTenEvents(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventData registerEvent(::std::string userToken, EventData eventData, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventIntField(::std::string userToken, int eventId, EventField field, int newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventStringField(::std::string userToken, int eventId, EventField field, ::std::string newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventDoubleField(::std::string userToken, int eventId, EventField field, double newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addServiceToEvent(::std::string userToken, ServiceInfo serviceInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addServiceToEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceIntField(::std::string userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceStringField(::std::string userToken, int serviceId, ServiceField field, ::std::string newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceDoubleField(::std::string userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int registerClient(::std::string userToken, ClientInfo clientInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyClient(::std::string userToken, ClientInfo clientInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void deleteRecord(::std::string userToken, Table table, int id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteRecord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace EventModule
{

class EventInterfacePrx : public virtual ::Ice::Proxy<EventInterfacePrx, ::Ice::ObjectPrx>
{
public:

    SeqEventData getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::SeqEventData>(true, this, &EventInterfacePrx::_iceI_getEventsData, userToken, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEventsDataAsync(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::SeqEventData>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::SeqEventData, P>(false, this, &EventInterfacePrx::_iceI_getEventsData, userToken, context);
    }

    ::std::function<void()>
    getEventsDataAsync(const ::std::string& userToken,
                       ::std::function<void(::EventModule::SeqEventData)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::SeqEventData>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_getEventsData, userToken, context);
    }

    /// \cond INTERNAL
    void _iceI_getEventsData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::SeqEventData>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    SeqClientInfo getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::SeqClientInfo>(true, this, &EventInterfacePrx::_iceI_getClientsByName, userToken, partialName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClientsByNameAsync(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::SeqClientInfo>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::SeqClientInfo, P>(false, this, &EventInterfacePrx::_iceI_getClientsByName, userToken, partialName, context);
    }

    ::std::function<void()>
    getClientsByNameAsync(const ::std::string& userToken, const ::std::string& partialName,
                          ::std::function<void(::EventModule::SeqClientInfo)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::SeqClientInfo>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_getClientsByName, userToken, partialName, context);
    }

    /// \cond INTERNAL
    void _iceI_getClientsByName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::SeqClientInfo>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    SeqClientInfo getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::SeqClientInfo>(true, this, &EventInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClientsByPhoneAsync(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::SeqClientInfo>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::SeqClientInfo, P>(false, this, &EventInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context);
    }

    ::std::function<void()>
    getClientsByPhoneAsync(const ::std::string& userToken, const ::std::string& partialPhone,
                           ::std::function<void(::EventModule::SeqClientInfo)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::SeqClientInfo>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_getClientsByPhone, userToken, partialPhone, context);
    }

    /// \cond INTERNAL
    void _iceI_getClientsByPhone(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::SeqClientInfo>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    EventData getEventData(const ::std::string& userToken, int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::EventData>(true, this, &EventInterfacePrx::_iceI_getEventData, userToken, eventId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEventDataAsync(const ::std::string& userToken, int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::EventData>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::EventData, P>(false, this, &EventInterfacePrx::_iceI_getEventData, userToken, eventId, context);
    }

    ::std::function<void()>
    getEventDataAsync(const ::std::string& userToken, int eventId,
                      ::std::function<void(::EventModule::EventData)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::EventData>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_getEventData, userToken, eventId, context);
    }

    /// \cond INTERNAL
    void _iceI_getEventData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::EventData>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    SeqEventData getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::SeqEventData>(true, this, &EventInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTenEventsAsync(const ::std::string& userToken, const ::std::string& fromDate, int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::SeqEventData>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::SeqEventData, P>(false, this, &EventInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context);
    }

    ::std::function<void()>
    getTenEventsAsync(const ::std::string& userToken, const ::std::string& fromDate, int offset,
                      ::std::function<void(::EventModule::SeqEventData)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::SeqEventData>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_getTenEvents, userToken, fromDate, offset, context);
    }

    /// \cond INTERNAL
    void _iceI_getTenEvents(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::SeqEventData>>&, const ::std::string&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    EventData registerEvent(const ::std::string& userToken, const EventData& eventData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::EventModule::EventData>(true, this, &EventInterfacePrx::_iceI_registerEvent, userToken, eventData, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerEventAsync(const ::std::string& userToken, const EventData& eventData, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::EventModule::EventData>>().get_future())
    {
        return _makePromiseOutgoing<::EventModule::EventData, P>(false, this, &EventInterfacePrx::_iceI_registerEvent, userToken, eventData, context);
    }

    ::std::function<void()>
    registerEventAsync(const ::std::string& userToken, const EventData& eventData,
                       ::std::function<void(::EventModule::EventData)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::EventModule::EventData>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_registerEvent, userToken, eventData, context);
    }

    /// \cond INTERNAL
    void _iceI_registerEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::EventModule::EventData>>&, const ::std::string&, const EventData&, const ::Ice::Context&);
    /// \endcond

    void modifyEventIntField(const ::std::string& userToken, int eventId, EventField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventIntFieldAsync(const ::std::string& userToken, int eventId, EventField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventIntFieldAsync(const ::std::string& userToken, int eventId, EventField field, int newValue,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyEventIntField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventIntField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, int, const ::Ice::Context&);
    /// \endcond

    void modifyEventStringField(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventStringFieldAsync(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventStringFieldAsync(const ::std::string& userToken, int eventId, EventField field, const ::std::string& newValue,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyEventStringField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventStringField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void modifyEventDoubleField(const ::std::string& userToken, int eventId, EventField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyEventDoubleFieldAsync(const ::std::string& userToken, int eventId, EventField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context);
    }

    ::std::function<void()>
    modifyEventDoubleFieldAsync(const ::std::string& userToken, int eventId, EventField field, double newValue,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyEventDoubleField, userToken, eventId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyEventDoubleField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, EventField, double, const ::Ice::Context&);
    /// \endcond

    void addServiceToEvent(const ::std::string& userToken, const ServiceInfo& serviceInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_addServiceToEvent, userToken, serviceInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addServiceToEventAsync(const ::std::string& userToken, const ServiceInfo& serviceInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_addServiceToEvent, userToken, serviceInfo, context);
    }

    ::std::function<void()>
    addServiceToEventAsync(const ::std::string& userToken, const ServiceInfo& serviceInfo,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_addServiceToEvent, userToken, serviceInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_addServiceToEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ServiceInfo&, const ::Ice::Context&);
    /// \endcond

    void modifyServiceIntField(const ::std::string& userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceIntFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceIntFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, int newValue,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyServiceIntField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceIntField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, int, const ::Ice::Context&);
    /// \endcond

    void modifyServiceStringField(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceStringFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceStringFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, const ::std::string& newValue,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyServiceStringField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceStringField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void modifyServiceDoubleField(const ::std::string& userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyServiceDoubleFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context);
    }

    ::std::function<void()>
    modifyServiceDoubleFieldAsync(const ::std::string& userToken, int serviceId, ServiceField field, double newValue,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyServiceDoubleField, userToken, serviceId, field, newValue, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyServiceDoubleField(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, ServiceField, double, const ::Ice::Context&);
    /// \endcond

    int registerClient(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &EventInterfacePrx::_iceI_registerClient, userToken, clientInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerClientAsync(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &EventInterfacePrx::_iceI_registerClient, userToken, clientInfo, context);
    }

    ::std::function<void()>
    registerClientAsync(const ::std::string& userToken, const ClientInfo& clientInfo,
                        ::std::function<void(int)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_registerClient, userToken, clientInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_registerClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ClientInfo&, const ::Ice::Context&);
    /// \endcond

    void modifyClient(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_modifyClient, userToken, clientInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto modifyClientAsync(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_modifyClient, userToken, clientInfo, context);
    }

    ::std::function<void()>
    modifyClientAsync(const ::std::string& userToken, const ClientInfo& clientInfo,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_modifyClient, userToken, clientInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_modifyClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ClientInfo&, const ::Ice::Context&);
    /// \endcond

    void deleteRecord(const ::std::string& userToken, Table table, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EventInterfacePrx::_iceI_deleteRecord, userToken, table, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto deleteRecordAsync(const ::std::string& userToken, Table table, int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EventInterfacePrx::_iceI_deleteRecord, userToken, table, id, context);
    }

    ::std::function<void()>
    deleteRecordAsync(const ::std::string& userToken, Table table, int id,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &EventModule::EventInterfacePrx::_iceI_deleteRecord, userToken, table, id, context);
    }

    /// \cond INTERNAL
    void _iceI_deleteRecord(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, Table, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EventInterfacePrx() = default;
    friend ::std::shared_ptr<EventInterfacePrx> IceInternal::createProxy<EventInterfacePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::EventModule::Table>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::EventField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::ServiceField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::ClientField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::EventModule::ClientInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventModule::ClientInfo, S>
{
    static void read(S* istr, ::EventModule::ClientInfo& v)
    {
        istr->readAll(v.id, v.name, v.phone, v.specialNote);
    }
};

template<>
struct StreamableTraits<::EventModule::ServiceInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 25;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventModule::ServiceInfo, S>
{
    static void read(S* istr, ::EventModule::ServiceInfo& v)
    {
        istr->readAll(v.id, v.eventId, v.providerIdentity, v.providerService, v.dateTime, v.duration, v.cost, v.description, v.observations);
    }
};

template<>
struct StreamableTraits<::EventModule::EventInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventModule::EventInfo, S>
{
    static void read(S* istr, ::EventModule::EventInfo& v)
    {
        istr->readAll(v.id, v.clientId, v.duration, v.dateTime, v.location, v.description);
    }
};

template<>
struct StreamableTraits<::EventModule::EventData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 27;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::EventModule::EventData, S>
{
    static void read(S* istr, ::EventModule::EventData& v)
    {
        istr->readAll(v.clientInfo, v.eventInfo, v.seqServiceInfo);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace EventModule
{

using EventInterfacePtr = ::std::shared_ptr<EventInterface>;
using EventInterfacePrxPtr = ::std::shared_ptr<EventInterfacePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace EventModule
{

class EventInterface;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EventInterface>&);
::IceProxy::Ice::Object* upCast(EventInterface*);
/// \endcond

}

}

namespace EventModule
{

class EventInterface;
/// \cond INTERNAL
::Ice::Object* upCast(EventInterface*);
/// \endcond
typedef ::IceInternal::Handle< EventInterface> EventInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::EventModule::EventInterface> EventInterfacePrx;
typedef EventInterfacePrx EventInterfacePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EventInterfacePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace EventModule
{

enum Table
{
    clients,
    events,
    services
};

enum EventField
{
    clientId,
    dateTime,
    date,
    time,
    duration,
    location,
    description
};

enum ServiceField
{
    providerIdentity,
    providerService,
    dateTime,
    duration,
    cost,
    description,
    observations
};

enum ClientField
{
    name,
    phone,
    specialNote
};

struct ClientInfo
{
    ::Ice::Int id;
    ::std::string name;
    ::std::string phone;
    ::std::string specialNote;

    bool operator==(const ClientInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(name != rhs_.name)
        {
            return false;
        }
        if(phone != rhs_.phone)
        {
            return false;
        }
        if(specialNote != rhs_.specialNote)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClientInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(name < rhs_.name)
        {
            return true;
        }
        else if(rhs_.name < name)
        {
            return false;
        }
        if(phone < rhs_.phone)
        {
            return true;
        }
        else if(rhs_.phone < phone)
        {
            return false;
        }
        if(specialNote < rhs_.specialNote)
        {
            return true;
        }
        else if(rhs_.specialNote < specialNote)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClientInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClientInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClientInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClientInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ClientInfo> SeqClientInfo;

struct ServiceInfo
{
    ::Ice::Int id;
    ::Ice::Int eventId;
    ::std::string providerIdentity;
    ::std::string providerService;
    ::std::string dateTime;
    ::Ice::Double duration;
    ::Ice::Int cost;
    ::std::string description;
    ::std::string observations;
};

typedef ::std::vector<ServiceInfo> SeqServiceInfo;

struct EventInfo
{
    ::Ice::Int id;
    ::Ice::Int clientId;
    ::Ice::Double duration;
    ::std::string dateTime;
    ::std::string location;
    ::std::string description;
};

typedef ::std::vector<EventInfo> SeqEventInfo;

struct EventData
{
    ::EventModule::ClientInfo clientInfo;
    ::EventModule::EventInfo eventInfo;
    ::EventModule::SeqServiceInfo seqServiceInfo;
};

typedef ::std::vector<EventData> SeqEventData;

}

namespace EventModule
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventsData.
 */
class Callback_EventInterface_getEventsData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_getEventsData_Base> Callback_EventInterface_getEventsDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByName.
 */
class Callback_EventInterface_getClientsByName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_getClientsByName_Base> Callback_EventInterface_getClientsByNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByPhone.
 */
class Callback_EventInterface_getClientsByPhone_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_getClientsByPhone_Base> Callback_EventInterface_getClientsByPhonePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventData.
 */
class Callback_EventInterface_getEventData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_getEventData_Base> Callback_EventInterface_getEventDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getTenEvents.
 */
class Callback_EventInterface_getTenEvents_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_getTenEvents_Base> Callback_EventInterface_getTenEventsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerEvent.
 */
class Callback_EventInterface_registerEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_registerEvent_Base> Callback_EventInterface_registerEventPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventIntField.
 */
class Callback_EventInterface_modifyEventIntField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyEventIntField_Base> Callback_EventInterface_modifyEventIntFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventStringField.
 */
class Callback_EventInterface_modifyEventStringField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyEventStringField_Base> Callback_EventInterface_modifyEventStringFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventDoubleField.
 */
class Callback_EventInterface_modifyEventDoubleField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyEventDoubleField_Base> Callback_EventInterface_modifyEventDoubleFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_addServiceToEvent.
 */
class Callback_EventInterface_addServiceToEvent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_addServiceToEvent_Base> Callback_EventInterface_addServiceToEventPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceIntField.
 */
class Callback_EventInterface_modifyServiceIntField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyServiceIntField_Base> Callback_EventInterface_modifyServiceIntFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceStringField.
 */
class Callback_EventInterface_modifyServiceStringField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyServiceStringField_Base> Callback_EventInterface_modifyServiceStringFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceDoubleField.
 */
class Callback_EventInterface_modifyServiceDoubleField_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyServiceDoubleField_Base> Callback_EventInterface_modifyServiceDoubleFieldPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerClient.
 */
class Callback_EventInterface_registerClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_registerClient_Base> Callback_EventInterface_registerClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyClient.
 */
class Callback_EventInterface_modifyClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_modifyClient_Base> Callback_EventInterface_modifyClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::EventModule::EventInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_deleteRecord.
 */
class Callback_EventInterface_deleteRecord_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EventInterface_deleteRecord_Base> Callback_EventInterface_deleteRecordPtr;

}

namespace IceProxy
{

namespace EventModule
{

class EventInterface : public virtual ::Ice::Proxy<EventInterface, ::IceProxy::Ice::Object>
{
public:

    ::EventModule::SeqEventData getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEventsData(_iceI_begin_getEventsData(userToken, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEventsData(userToken, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::EventModule::Callback_EventInterface_getEventsDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventsData(const ::std::string& userToken, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_getEventsDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventsData(userToken, context, cb, cookie);
    }

    ::EventModule::SeqEventData end_getEventsData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEventsData(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventModule::SeqClientInfo getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClientsByName(_iceI_begin_getClientsByName(userToken, partialName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::EventModule::Callback_EventInterface_getClientsByNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_getClientsByNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByName(userToken, partialName, context, cb, cookie);
    }

    ::EventModule::SeqClientInfo end_getClientsByName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClientsByName(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventModule::SeqClientInfo getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClientsByPhone(_iceI_begin_getClientsByPhone(userToken, partialPhone, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::EventModule::Callback_EventInterface_getClientsByPhonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_getClientsByPhonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientsByPhone(userToken, partialPhone, context, cb, cookie);
    }

    ::EventModule::SeqClientInfo end_getClientsByPhone(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClientsByPhone(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventModule::EventData getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEventData(_iceI_begin_getEventData(userToken, eventId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::EventModule::Callback_EventInterface_getEventDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_getEventDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEventData(userToken, eventId, context, cb, cookie);
    }

    ::EventModule::EventData end_getEventData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEventData(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventModule::SeqEventData getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTenEvents(_iceI_begin_getTenEvents(userToken, fromDate, offset, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::EventModule::Callback_EventInterface_getTenEventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_getTenEventsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTenEvents(userToken, fromDate, offset, context, cb, cookie);
    }

    ::EventModule::SeqEventData end_getTenEvents(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTenEvents(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::EventModule::EventData registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerEvent(_iceI_begin_registerEvent(userToken, eventData, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerEvent(userToken, eventData, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventData, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::EventModule::Callback_EventInterface_registerEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventData, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerEvent(const ::std::string& userToken, const ::EventModule::EventData& eventData, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_registerEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerEvent(userToken, eventData, context, cb, cookie);
    }

    ::EventModule::EventData end_registerEvent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerEvent(const ::std::string&, const ::EventModule::EventData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventIntField(_iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::EventModule::Callback_EventInterface_modifyEventIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyEventIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventIntField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventIntField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventIntField(const ::std::string&, ::Ice::Int, ::EventModule::EventField, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventStringField(_iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::EventModule::Callback_EventInterface_modifyEventStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, const ::std::string& newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyEventStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventStringField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventStringField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventStringField(const ::std::string&, ::Ice::Int, ::EventModule::EventField, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyEventDoubleField(_iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::EventModule::Callback_EventInterface_modifyEventDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, ::EventModule::EventField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyEventDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyEventDoubleField(userToken, eventId, field, newValue, context, cb, cookie);
    }

    void end_modifyEventDoubleField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyEventDoubleField(const ::std::string&, ::Ice::Int, ::EventModule::EventField, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addServiceToEvent(_iceI_begin_addServiceToEvent(userToken, serviceInfo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceInfo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceInfo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::EventModule::Callback_EventInterface_addServiceToEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addServiceToEvent(const ::std::string& userToken, const ::EventModule::ServiceInfo& serviceInfo, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_addServiceToEventPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addServiceToEvent(userToken, serviceInfo, context, cb, cookie);
    }

    void end_addServiceToEvent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addServiceToEvent(const ::std::string&, const ::EventModule::ServiceInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceIntField(_iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::EventModule::Callback_EventInterface_modifyServiceIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Int newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyServiceIntFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceIntField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceIntField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceIntField(const ::std::string&, ::Ice::Int, ::EventModule::ServiceField, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceStringField(_iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::EventModule::Callback_EventInterface_modifyServiceStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, const ::std::string& newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyServiceStringFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceStringField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceStringField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceStringField(const ::std::string&, ::Ice::Int, ::EventModule::ServiceField, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyServiceDoubleField(_iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::EventModule::Callback_EventInterface_modifyServiceDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ::EventModule::ServiceField field, ::Ice::Double newValue, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyServiceDoubleFieldPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyServiceDoubleField(userToken, serviceId, field, newValue, context, cb, cookie);
    }

    void end_modifyServiceDoubleField(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyServiceDoubleField(const ::std::string&, ::Ice::Int, ::EventModule::ServiceField, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_registerClient(_iceI_begin_registerClient(userToken, clientInfo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerClient(userToken, clientInfo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientInfo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::EventModule::Callback_EventInterface_registerClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_registerClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerClient(userToken, clientInfo, context, cb, cookie);
    }

    ::Ice::Int end_registerClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerClient(const ::std::string&, const ::EventModule::ClientInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_modifyClient(_iceI_begin_modifyClient(userToken, clientInfo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_modifyClient(userToken, clientInfo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientInfo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::EventModule::Callback_EventInterface_modifyClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_modifyClient(const ::std::string& userToken, const ::EventModule::ClientInfo& clientInfo, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_modifyClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_modifyClient(userToken, clientInfo, context, cb, cookie);
    }

    void end_modifyClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_modifyClient(const ::std::string&, const ::EventModule::ClientInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_deleteRecord(_iceI_begin_deleteRecord(userToken, table, id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::EventModule::Callback_EventInterface_deleteRecordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteRecord(const ::std::string& userToken, ::EventModule::Table table, ::Ice::Int id, const ::Ice::Context& context, const ::EventModule::Callback_EventInterface_deleteRecordPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteRecord(userToken, table, id, context, cb, cookie);
    }

    void end_deleteRecord(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_deleteRecord(const ::std::string&, ::EventModule::Table, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace EventModule
{

class EventInterface : public virtual ::Ice::Object
{
public:

    typedef EventInterfacePrx ProxyType;
    typedef EventInterfacePtr PointerType;

    virtual ~EventInterface();

#ifdef ICE_CPP11_COMPILER
    EventInterface() = default;
    EventInterface(const EventInterface&) = default;
    EventInterface& operator=(const EventInterface&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual SeqEventData getEventsData(const ::std::string& userToken, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventsData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClientInfo getClientsByName(const ::std::string& userToken, const ::std::string& partialName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqClientInfo getClientsByPhone(const ::std::string& userToken, const ::std::string& partialPhone, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientsByPhone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventData getEventData(const ::std::string& userToken, ::Ice::Int eventId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEventData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SeqEventData getTenEvents(const ::std::string& userToken, const ::std::string& fromDate, ::Ice::Int offset, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTenEvents(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EventData registerEvent(const ::std::string& userToken, const EventData& eventData, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventIntField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, ::Ice::Int newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventStringField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, const ::std::string& newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyEventDoubleField(const ::std::string& userToken, ::Ice::Int eventId, EventField field, ::Ice::Double newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyEventDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addServiceToEvent(const ::std::string& userToken, const ServiceInfo& serviceInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addServiceToEvent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceIntField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, ::Ice::Int newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceIntField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceStringField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, const ::std::string& newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceStringField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyServiceDoubleField(const ::std::string& userToken, ::Ice::Int serviceId, ServiceField field, ::Ice::Double newValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyServiceDoubleField(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int registerClient(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void modifyClient(const ::std::string& userToken, const ClientInfo& clientInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_modifyClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void deleteRecord(const ::std::string& userToken, Table table, ::Ice::Int id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteRecord(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const EventInterface& lhs, const EventInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EventInterface& lhs, const EventInterface& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::EventModule::Table>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::EventField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::ServiceField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::ClientField>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::EventModule::ClientInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventModule::ClientInfo, S>
{
    static void write(S* ostr, const ::EventModule::ClientInfo& v)
    {
        ostr->write(v.id);
        ostr->write(v.name);
        ostr->write(v.phone);
        ostr->write(v.specialNote);
    }
};

template<typename S>
struct StreamReader< ::EventModule::ClientInfo, S>
{
    static void read(S* istr, ::EventModule::ClientInfo& v)
    {
        istr->read(v.id);
        istr->read(v.name);
        istr->read(v.phone);
        istr->read(v.specialNote);
    }
};

template<>
struct StreamableTraits< ::EventModule::ServiceInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 25;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventModule::ServiceInfo, S>
{
    static void write(S* ostr, const ::EventModule::ServiceInfo& v)
    {
        ostr->write(v.id);
        ostr->write(v.eventId);
        ostr->write(v.providerIdentity);
        ostr->write(v.providerService);
        ostr->write(v.dateTime);
        ostr->write(v.duration);
        ostr->write(v.cost);
        ostr->write(v.description);
        ostr->write(v.observations);
    }
};

template<typename S>
struct StreamReader< ::EventModule::ServiceInfo, S>
{
    static void read(S* istr, ::EventModule::ServiceInfo& v)
    {
        istr->read(v.id);
        istr->read(v.eventId);
        istr->read(v.providerIdentity);
        istr->read(v.providerService);
        istr->read(v.dateTime);
        istr->read(v.duration);
        istr->read(v.cost);
        istr->read(v.description);
        istr->read(v.observations);
    }
};

template<>
struct StreamableTraits< ::EventModule::EventInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventModule::EventInfo, S>
{
    static void write(S* ostr, const ::EventModule::EventInfo& v)
    {
        ostr->write(v.id);
        ostr->write(v.clientId);
        ostr->write(v.duration);
        ostr->write(v.dateTime);
        ostr->write(v.location);
        ostr->write(v.description);
    }
};

template<typename S>
struct StreamReader< ::EventModule::EventInfo, S>
{
    static void read(S* istr, ::EventModule::EventInfo& v)
    {
        istr->read(v.id);
        istr->read(v.clientId);
        istr->read(v.duration);
        istr->read(v.dateTime);
        istr->read(v.location);
        istr->read(v.description);
    }
};

template<>
struct StreamableTraits< ::EventModule::EventData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 27;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::EventModule::EventData, S>
{
    static void write(S* ostr, const ::EventModule::EventData& v)
    {
        ostr->write(v.clientInfo);
        ostr->write(v.eventInfo);
        ostr->write(v.seqServiceInfo);
    }
};

template<typename S>
struct StreamReader< ::EventModule::EventData, S>
{
    static void read(S* istr, ::EventModule::EventData& v)
    {
        istr->read(v.clientInfo);
        istr->read(v.eventInfo);
        istr->read(v.seqServiceInfo);
    }
};

}
/// \endcond

namespace EventModule
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventsData.
 */
template<class T>
class CallbackNC_EventInterface_getEventsData : public Callback_EventInterface_getEventsData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqEventData&);

    CallbackNC_EventInterface_getEventsData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventData ret;
        try
        {
            ret = proxy->end_getEventsData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventsData.
 */
template<class T> Callback_EventInterface_getEventsDataPtr
newCallback_EventInterface_getEventsData(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getEventsData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventsData.
 */
template<class T> Callback_EventInterface_getEventsDataPtr
newCallback_EventInterface_getEventsData(T* instance, void (T::*cb)(const SeqEventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getEventsData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventsData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventsData.
 */
template<class T, typename CT>
class Callback_EventInterface_getEventsData : public Callback_EventInterface_getEventsData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqEventData&, const CT&);

    Callback_EventInterface_getEventsData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventData ret;
        try
        {
            ret = proxy->end_getEventsData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventsData.
 */
template<class T, typename CT> Callback_EventInterface_getEventsDataPtr
newCallback_EventInterface_getEventsData(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getEventsData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventsData.
 */
template<class T, typename CT> Callback_EventInterface_getEventsDataPtr
newCallback_EventInterface_getEventsData(T* instance, void (T::*cb)(const SeqEventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getEventsData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByName.
 */
template<class T>
class CallbackNC_EventInterface_getClientsByName : public Callback_EventInterface_getClientsByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqClientInfo&);

    CallbackNC_EventInterface_getClientsByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqClientInfo ret;
        try
        {
            ret = proxy->end_getClientsByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByName.
 */
template<class T> Callback_EventInterface_getClientsByNamePtr
newCallback_EventInterface_getClientsByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getClientsByName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByName.
 */
template<class T> Callback_EventInterface_getClientsByNamePtr
newCallback_EventInterface_getClientsByName(T* instance, void (T::*cb)(const SeqClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getClientsByName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByName.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByName.
 */
template<class T, typename CT>
class Callback_EventInterface_getClientsByName : public Callback_EventInterface_getClientsByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqClientInfo&, const CT&);

    Callback_EventInterface_getClientsByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqClientInfo ret;
        try
        {
            ret = proxy->end_getClientsByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByName.
 */
template<class T, typename CT> Callback_EventInterface_getClientsByNamePtr
newCallback_EventInterface_getClientsByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getClientsByName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByName.
 */
template<class T, typename CT> Callback_EventInterface_getClientsByNamePtr
newCallback_EventInterface_getClientsByName(T* instance, void (T::*cb)(const SeqClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getClientsByName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByPhone.
 */
template<class T>
class CallbackNC_EventInterface_getClientsByPhone : public Callback_EventInterface_getClientsByPhone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqClientInfo&);

    CallbackNC_EventInterface_getClientsByPhone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqClientInfo ret;
        try
        {
            ret = proxy->end_getClientsByPhone(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 */
template<class T> Callback_EventInterface_getClientsByPhonePtr
newCallback_EventInterface_getClientsByPhone(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getClientsByPhone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 */
template<class T> Callback_EventInterface_getClientsByPhonePtr
newCallback_EventInterface_getClientsByPhone(T* instance, void (T::*cb)(const SeqClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getClientsByPhone<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getClientsByPhone.
 */
template<class T, typename CT>
class Callback_EventInterface_getClientsByPhone : public Callback_EventInterface_getClientsByPhone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqClientInfo&, const CT&);

    Callback_EventInterface_getClientsByPhone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqClientInfo ret;
        try
        {
            ret = proxy->end_getClientsByPhone(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 */
template<class T, typename CT> Callback_EventInterface_getClientsByPhonePtr
newCallback_EventInterface_getClientsByPhone(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getClientsByPhone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getClientsByPhone.
 */
template<class T, typename CT> Callback_EventInterface_getClientsByPhonePtr
newCallback_EventInterface_getClientsByPhone(T* instance, void (T::*cb)(const SeqClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getClientsByPhone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventData.
 */
template<class T>
class CallbackNC_EventInterface_getEventData : public Callback_EventInterface_getEventData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EventData&);

    CallbackNC_EventInterface_getEventData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        EventData ret;
        try
        {
            ret = proxy->end_getEventData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventData.
 */
template<class T> Callback_EventInterface_getEventDataPtr
newCallback_EventInterface_getEventData(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getEventData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventData.
 */
template<class T> Callback_EventInterface_getEventDataPtr
newCallback_EventInterface_getEventData(T* instance, void (T::*cb)(const EventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getEventData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_getEventData.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getEventData.
 */
template<class T, typename CT>
class Callback_EventInterface_getEventData : public Callback_EventInterface_getEventData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EventData&, const CT&);

    Callback_EventInterface_getEventData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        EventData ret;
        try
        {
            ret = proxy->end_getEventData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventData.
 */
template<class T, typename CT> Callback_EventInterface_getEventDataPtr
newCallback_EventInterface_getEventData(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getEventData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getEventData.
 */
template<class T, typename CT> Callback_EventInterface_getEventDataPtr
newCallback_EventInterface_getEventData(T* instance, void (T::*cb)(const EventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getEventData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getTenEvents.
 */
template<class T>
class CallbackNC_EventInterface_getTenEvents : public Callback_EventInterface_getTenEvents_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SeqEventData&);

    CallbackNC_EventInterface_getTenEvents(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventData ret;
        try
        {
            ret = proxy->end_getTenEvents(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getTenEvents.
 */
template<class T> Callback_EventInterface_getTenEventsPtr
newCallback_EventInterface_getTenEvents(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getTenEvents<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getTenEvents.
 */
template<class T> Callback_EventInterface_getTenEventsPtr
newCallback_EventInterface_getTenEvents(T* instance, void (T::*cb)(const SeqEventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_getTenEvents<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_getTenEvents.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_getTenEvents.
 */
template<class T, typename CT>
class Callback_EventInterface_getTenEvents : public Callback_EventInterface_getTenEvents_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SeqEventData&, const CT&);

    Callback_EventInterface_getTenEvents(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        SeqEventData ret;
        try
        {
            ret = proxy->end_getTenEvents(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getTenEvents.
 */
template<class T, typename CT> Callback_EventInterface_getTenEventsPtr
newCallback_EventInterface_getTenEvents(const IceUtil::Handle<T>& instance, void (T::*cb)(const SeqEventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getTenEvents<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_getTenEvents.
 */
template<class T, typename CT> Callback_EventInterface_getTenEventsPtr
newCallback_EventInterface_getTenEvents(T* instance, void (T::*cb)(const SeqEventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_getTenEvents<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerEvent.
 */
template<class T>
class CallbackNC_EventInterface_registerEvent : public Callback_EventInterface_registerEvent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EventData&);

    CallbackNC_EventInterface_registerEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        EventData ret;
        try
        {
            ret = proxy->end_registerEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerEvent.
 */
template<class T> Callback_EventInterface_registerEventPtr
newCallback_EventInterface_registerEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_registerEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerEvent.
 */
template<class T> Callback_EventInterface_registerEventPtr
newCallback_EventInterface_registerEvent(T* instance, void (T::*cb)(const EventData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_registerEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerEvent.
 */
template<class T, typename CT>
class Callback_EventInterface_registerEvent : public Callback_EventInterface_registerEvent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EventData&, const CT&);

    Callback_EventInterface_registerEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        EventData ret;
        try
        {
            ret = proxy->end_registerEvent(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerEvent.
 */
template<class T, typename CT> Callback_EventInterface_registerEventPtr
newCallback_EventInterface_registerEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const EventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_registerEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerEvent.
 */
template<class T, typename CT> Callback_EventInterface_registerEventPtr
newCallback_EventInterface_registerEvent(T* instance, void (T::*cb)(const EventData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_registerEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventIntField.
 */
template<class T>
class CallbackNC_EventInterface_modifyEventIntField : public Callback_EventInterface_modifyEventIntField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyEventIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventIntField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyEventIntField : public Callback_EventInterface_modifyEventIntField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyEventIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventIntFieldPtr
newCallback_EventInterface_modifyEventIntField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventStringField.
 */
template<class T>
class CallbackNC_EventInterface_modifyEventStringField : public Callback_EventInterface_modifyEventStringField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyEventStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventStringField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyEventStringField : public Callback_EventInterface_modifyEventStringField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyEventStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventStringFieldPtr
newCallback_EventInterface_modifyEventStringField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventDoubleField.
 */
template<class T>
class CallbackNC_EventInterface_modifyEventDoubleField : public Callback_EventInterface_modifyEventDoubleField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyEventDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyEventDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyEventDoubleField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyEventDoubleField : public Callback_EventInterface_modifyEventDoubleField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyEventDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyEventDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyEventDoubleFieldPtr
newCallback_EventInterface_modifyEventDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyEventDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_addServiceToEvent.
 */
template<class T>
class CallbackNC_EventInterface_addServiceToEvent : public Callback_EventInterface_addServiceToEvent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_addServiceToEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_addServiceToEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_addServiceToEvent<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_addServiceToEvent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_addServiceToEvent<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_addServiceToEvent.
 */
template<class T, typename CT>
class Callback_EventInterface_addServiceToEvent : public Callback_EventInterface_addServiceToEvent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_addServiceToEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_addServiceToEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_addServiceToEvent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_addServiceToEvent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_addServiceToEvent.
 */
template<class T, typename CT> Callback_EventInterface_addServiceToEventPtr
newCallback_EventInterface_addServiceToEvent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_addServiceToEvent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceIntField.
 */
template<class T>
class CallbackNC_EventInterface_modifyServiceIntField : public Callback_EventInterface_modifyServiceIntField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyServiceIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceIntField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceIntField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceIntField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyServiceIntField : public Callback_EventInterface_modifyServiceIntField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyServiceIntField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceIntField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceIntField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceIntFieldPtr
newCallback_EventInterface_modifyServiceIntField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceIntField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceStringField.
 */
template<class T>
class CallbackNC_EventInterface_modifyServiceStringField : public Callback_EventInterface_modifyServiceStringField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyServiceStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceStringField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceStringField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceStringField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyServiceStringField : public Callback_EventInterface_modifyServiceStringField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyServiceStringField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceStringField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceStringField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceStringFieldPtr
newCallback_EventInterface_modifyServiceStringField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceStringField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceDoubleField.
 */
template<class T>
class CallbackNC_EventInterface_modifyServiceDoubleField : public Callback_EventInterface_modifyServiceDoubleField_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyServiceDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceDoubleField<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyServiceDoubleField<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyServiceDoubleField.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyServiceDoubleField : public Callback_EventInterface_modifyServiceDoubleField_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyServiceDoubleField(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceDoubleField<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyServiceDoubleField.
 */
template<class T, typename CT> Callback_EventInterface_modifyServiceDoubleFieldPtr
newCallback_EventInterface_modifyServiceDoubleField(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyServiceDoubleField<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerClient.
 */
template<class T>
class CallbackNC_EventInterface_registerClient : public Callback_EventInterface_registerClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_EventInterface_registerClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_registerClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerClient.
 */
template<class T> Callback_EventInterface_registerClientPtr
newCallback_EventInterface_registerClient(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_registerClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerClient.
 */
template<class T> Callback_EventInterface_registerClientPtr
newCallback_EventInterface_registerClient(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_registerClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_registerClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_registerClient.
 */
template<class T, typename CT>
class Callback_EventInterface_registerClient : public Callback_EventInterface_registerClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_EventInterface_registerClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EventInterfacePrx proxy = EventInterfacePrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_registerClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerClient.
 */
template<class T, typename CT> Callback_EventInterface_registerClientPtr
newCallback_EventInterface_registerClient(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_registerClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_registerClient.
 */
template<class T, typename CT> Callback_EventInterface_registerClientPtr
newCallback_EventInterface_registerClient(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_registerClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyClient.
 */
template<class T>
class CallbackNC_EventInterface_modifyClient : public Callback_EventInterface_modifyClient_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_modifyClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyClient<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_modifyClient<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_modifyClient.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_modifyClient.
 */
template<class T, typename CT>
class Callback_EventInterface_modifyClient : public Callback_EventInterface_modifyClient_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_modifyClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_modifyClient.
 */
template<class T, typename CT> Callback_EventInterface_modifyClientPtr
newCallback_EventInterface_modifyClient(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_modifyClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::EventModule::EventInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_deleteRecord.
 */
template<class T>
class CallbackNC_EventInterface_deleteRecord : public Callback_EventInterface_deleteRecord_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EventInterface_deleteRecord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_deleteRecord<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_deleteRecord<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_deleteRecord<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EventInterface_deleteRecord<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::EventModule::EventInterface::begin_deleteRecord.
 * Create a wrapper instance by calling ::EventModule::newCallback_EventInterface_deleteRecord.
 */
template<class T, typename CT>
class Callback_EventInterface_deleteRecord : public Callback_EventInterface_deleteRecord_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EventInterface_deleteRecord(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_deleteRecord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_deleteRecord<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_deleteRecord<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::EventModule::EventInterface::begin_deleteRecord.
 */
template<class T, typename CT> Callback_EventInterface_deleteRecordPtr
newCallback_EventInterface_deleteRecord(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EventInterface_deleteRecord<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
